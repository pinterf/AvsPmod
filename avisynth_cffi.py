# avisynth - Python AviSynth wrapper
# 
# Copyright 2014-2016 the AvsPmod authors <https://github.com/avspmod/avspmod>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
#  http://www.gnu.org/copyleft/gpl.html .

# Dependencies:
#     Python (tested on v2.7)
#     cffi and its dependencies (tested on v0.8.1)
#         pycparser
#         Visual Studio 2008
#     avisynth_c.h (interface 6, AVS+, now part of the project)
# Optional:
#     global_vars.py (for specifying a custom shared library location)
#
# Notes:
#
# These bindings are NOT compatible with AVISYNTH_INTERFACE_VERSION 3.
#
# Define/undef AVSC_USE_STDCALL on the verify string as needed.
#
# libffi doesn't support passing structs or unions with bit-fields by value.
# To circunvent this some C wrappers were written for the affected functions. 
# This implies compiling a C extension (auto-generated by cffi).
# 
# The bindings uses LoadLibrary. For some reason it crashes for 32-bit. 
# Changing it to use dllimport makes it also work for 32-bit.


import sys
import traceback
import os.path
import collections

import cffi

    


# Try to load the library from the selected directory
try:
    import global_vars
    directory = global_vars.avisynth_library_dir
except:
    directory = ur''
if os.name == 'nt':
    if __debug__:
        if directory:
            ffi = cffi.FFI()
            ffi.cdef('bool SetDllDirectoryW(wchar_t *);')
            kernel32 = ffi.dlopen('kernel32')
            if hasattr(kernel32, 'SetDllDirectoryW'):
                print('Using a custom AviSynth directory:', directory)
                kernel32.SetDllDirectoryW(directory)
            else:
                print ('No SetDllDirectoryW on this version of Windows, '
                       'using AviSynth from PATH')
        else:
            print('Using AviSynth from PATH')
else: # TODO
    if __debug__:
        if directory:
            print('Using a custom AvxSynth directory:', directory)
        else:
            print('Using AvxSynth from LD_LIBRARY_PATH')


encoding = sys.getfilesystemencoding()

abi = False

cdef_str = r"""

typedef unsigned char BYTE;
typedef int64_t INT64;
typedef void *PVOID;
typedef PVOID HANDLE;
typedef HANDLE HINSTANCE;
typedef HINSTANCE HMODULE;


enum { AVISYNTH_INTERFACE_VERSION = ... };

enum {AVS_SAMPLE_INT8  = ..., // 1<<0,
      AVS_SAMPLE_INT16 = ..., // 1<<1,
      AVS_SAMPLE_INT24 = ..., // 1<<2,
      AVS_SAMPLE_INT32 = ..., // 1<<3,
      AVS_SAMPLE_FLOAT = ... // 1<<4
};

enum {AVS_PLANAR_Y = ..., // 1<<0,
      AVS_PLANAR_U = ..., // 1<<1,
      AVS_PLANAR_V = ..., // 1<<2,
      AVS_PLANAR_ALIGNED = ..., // 1<<3,
      AVS_PLANAR_Y_ALIGNED = ..., // AVS_PLANAR_Y|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_U_ALIGNED = ..., // AVS_PLANAR_U|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_V_ALIGNED = ..., // AVS_PLANAR_V|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_A = ..., // 1<<4,
      AVS_PLANAR_R = ..., // 1<<5,
      AVS_PLANAR_G = ..., // 1<<6,
      AVS_PLANAR_B = ..., // 1<<7,
      AVS_PLANAR_A_ALIGNED = ..., // AVS_PLANAR_A|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_R_ALIGNED = ..., // AVS_PLANAR_R|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_G_ALIGNED = ..., // AVS_PLANAR_G|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_B_ALIGNED = ... // AVS_PLANAR_B|AVS_PLANAR_ALIGNED
};

  // Colorspace properties.
enum {
    AVS_CS_YUVA = ..., // 1 << 27,
    AVS_CS_BGR = ..., // 1 << 28,
    AVS_CS_YUV = ..., // 1 << 29,
    AVS_CS_INTERLEAVED = ..., // = 1 << 30,
    AVS_CS_PLANAR = ..., // = 1 << 31,

    AVS_CS_SHIFT_SUB_WIDTH = ..., // = 0,
    AVS_CS_SHIFT_SUB_HEIGHT = ..., // = 8,
    AVS_CS_SHIFT_SAMPLE_BITS = ..., // = 16,

    AVS_CS_SUB_WIDTH_MASK = ..., // 7 << AVS_CS_SHIFT_SUB_WIDTH,
    AVS_CS_SUB_WIDTH_1 = ..., // 3 << AVS_CS_SHIFT_SUB_WIDTH, // YV24
    AVS_CS_SUB_WIDTH_2 = ..., // 0 << AVS_CS_SHIFT_SUB_WIDTH, // YV12, I420, YV16
    AVS_CS_SUB_WIDTH_4 = ..., // 1 << AVS_CS_SHIFT_SUB_WIDTH, // YUV9, YV411

    AVS_CS_VPLANEFIRST = ..., // 1 << 3, // YV12, YV16, YV24, YV411, YUV9
    AVS_CS_UPLANEFIRST = ..., // 1 << 4, // I420

    AVS_CS_SUB_HEIGHT_MASK = ..., // 7 << AVS_CS_SHIFT_SUB_HEIGHT,
    AVS_CS_SUB_HEIGHT_1 = ..., // 3 << AVS_CS_SHIFT_SUB_HEIGHT, // YV16, YV24, YV411
    AVS_CS_SUB_HEIGHT_2 = ..., // 0 << AVS_CS_SHIFT_SUB_HEIGHT, // YV12, I420
    AVS_CS_SUB_HEIGHT_4 = ..., // 1 << AVS_CS_SHIFT_SUB_HEIGHT, // YUV9

    AVS_CS_SAMPLE_BITS_MASK = ..., // 7 << AVS_CS_SHIFT_SAMPLE_BITS,
    AVS_CS_SAMPLE_BITS_8 = ..., // 0 << AVS_CS_SHIFT_SAMPLE_BITS,
    AVS_CS_SAMPLE_BITS_10 = ..., // 5 << AVS_CS_SHIFT_SAMPLE_BITS,
    AVS_CS_SAMPLE_BITS_12 = ..., // 6 << AVS_CS_SHIFT_SAMPLE_BITS,
    AVS_CS_SAMPLE_BITS_14 = ..., // 7 << AVS_CS_SHIFT_SAMPLE_BITS,
    AVS_CS_SAMPLE_BITS_16 = ..., // 1 << AVS_CS_SHIFT_SAMPLE_BITS,
    AVS_CS_SAMPLE_BITS_32 = ..., // 2 << AVS_CS_SHIFT_SAMPLE_BITS,

    AVS_CS_PLANAR_MASK = ..., // AVS_CS_PLANAR | AVS_CS_INTERLEAVED | AVS_CS_YUV | AVS_CS_BGR | AVS_CS_YUVA | AVS_CS_SAMPLE_BITS_MASK | AVS_CS_SUB_HEIGHT_MASK | AVS_CS_SUB_WIDTH_MASK,
    AVS_CS_PLANAR_FILTER = ..., // ~(AVS_CS_VPLANEFIRST | AVS_CS_UPLANEFIRST),

    AVS_CS_RGB_TYPE  = ..., // 1 << 0,
    AVS_CS_RGBA_TYPE = ..., // 1 << 1,

    AVS_CS_GENERIC_YUV420  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_2 | AVS_CS_SUB_WIDTH_2,  // 4:2:0 planar
    AVS_CS_GENERIC_YUV422  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_2,  // 4:2:2 planar
    AVS_CS_GENERIC_YUV444  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_1,  // 4:4:4 planar
    AVS_CS_GENERIC_Y       = ..., // AVS_CS_PLANAR | AVS_CS_INTERLEAVED | AVS_CS_YUV,                                             // Y only (4:0:0)
    AVS_CS_GENERIC_RGBP    = ..., // AVS_CS_PLANAR | AVS_CS_BGR | AVS_CS_RGB_TYPE,                                                // planar RGB
    AVS_CS_GENERIC_RGBAP   = ..., // AVS_CS_PLANAR | AVS_CS_BGR | AVS_CS_RGBA_TYPE,                                               // planar RGBA
    AVS_CS_GENERIC_YUVA420 = ..., // AVS_CS_PLANAR | AVS_CS_YUVA | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_2 | AVS_CS_SUB_WIDTH_2, // 4:2:0:A planar
    AVS_CS_GENERIC_YUVA422 = ..., // AVS_CS_PLANAR | AVS_CS_YUVA | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_2, // 4:2:2:A planar
    AVS_CS_GENERIC_YUVA444 = ..., // AVS_CS_PLANAR | AVS_CS_YUVA | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_1  // 4:4:4:A planar
}; 

  // Specific colorformats
enum {
  AVS_CS_UNKNOWN = 0,
  AVS_CS_BGR24 = ..., // AVS_CS_RGB_TYPE  | AVS_CS_BGR | AVS_CS_INTERLEAVED,
  AVS_CS_BGR32 = ..., // AVS_CS_RGBA_TYPE | AVS_CS_BGR | AVS_CS_INTERLEAVED,
  AVS_CS_YUY2 = ..., // 1<<2 | AVS_CS_YUV | AVS_CS_INTERLEAVED,
  //  AVS_CS_YV12  = 1<<3  Reserved
  //  AVS_CS_I420  = 1<<4  Reserved
  AVS_CS_RAW32 = ..., // 1<<5 | AVS_CS_INTERLEAVED,

  AVS_CS_YV24  = ..., // AVS_CS_GENERIC_YUV444 | AVS_CS_SAMPLE_BITS_8,  // YVU 4:4:4 planar
  AVS_CS_YV16  = ..., // AVS_CS_GENERIC_YUV422 | AVS_CS_SAMPLE_BITS_8,  // YVU 4:2:2 planar
  AVS_CS_YV12  = ..., // AVS_CS_GENERIC_YUV420 | AVS_CS_SAMPLE_BITS_8,  // YVU 4:2:0 planar
  AVS_CS_I420  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_UPLANEFIRST | AVS_CS_SUB_HEIGHT_2 | AVS_CS_SUB_WIDTH_2,  // YUV 4:2:0 planar
  AVS_CS_IYUV  = ..., // AVS_CS_I420,
  AVS_CS_YV411 = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_4,  // YVU 4:1:1 planar
  AVS_CS_YUV9  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_4 | AVS_CS_SUB_WIDTH_4,  // YVU 4:1:0 planar
  AVS_CS_Y8    = ..., // AVS_CS_GENERIC_Y | AVS_CS_SAMPLE_BITS_8,       // Y   4:0:0 planar

  //-------------------------
  // AVS16: new planar constants go live! Experimental PF 160613
  // 10-12-14-16 bit + planar RGB + BRG48/64 160725
  AVS_CS_YUV444P10 = ..., // AVS_CS_GENERIC_YUV444 | AVS_CS_SAMPLE_BITS_10, // YUV 4:4:4 10bit samples
  AVS_CS_YUV422P10 = ..., // AVS_CS_GENERIC_YUV422 | AVS_CS_SAMPLE_BITS_10, // YUV 4:2:2 10bit samples
  AVS_CS_YUV420P10 = ..., // AVS_CS_GENERIC_YUV420 | AVS_CS_SAMPLE_BITS_10, // YUV 4:2:0 10bit samples
  AVS_CS_Y10       = ..., // AVS_CS_GENERIC_Y | AVS_CS_SAMPLE_BITS_10,      // Y   4:0:0 10bit samples

  AVS_CS_YUV444P12 = ..., // AVS_CS_GENERIC_YUV444 | AVS_CS_SAMPLE_BITS_12, // YUV 4:4:4 12bit samples
  AVS_CS_YUV422P12 = ..., // AVS_CS_GENERIC_YUV422 | AVS_CS_SAMPLE_BITS_12, // YUV 4:2:2 12bit samples
  AVS_CS_YUV420P12 = ..., // AVS_CS_GENERIC_YUV420 | AVS_CS_SAMPLE_BITS_12, // YUV 4:2:0 12bit samples
  AVS_CS_Y12       = ..., // AVS_CS_GENERIC_Y | AVS_CS_SAMPLE_BITS_12,      // Y   4:0:0 12bit samples

  AVS_CS_YUV444P14 = ..., // AVS_CS_GENERIC_YUV444 | AVS_CS_SAMPLE_BITS_14, // YUV 4:4:4 14bit samples
  AVS_CS_YUV422P14 = ..., // AVS_CS_GENERIC_YUV422 | AVS_CS_SAMPLE_BITS_14, // YUV 4:2:2 14bit samples
  AVS_CS_YUV420P14 = ..., // AVS_CS_GENERIC_YUV420 | AVS_CS_SAMPLE_BITS_14, // YUV 4:2:0 14bit samples
  AVS_CS_Y14       = ..., // AVS_CS_GENERIC_Y | AVS_CS_SAMPLE_BITS_14,      // Y   4:0:0 14bit samples

  AVS_CS_YUV444P16 = ..., // AVS_CS_GENERIC_YUV444 | AVS_CS_SAMPLE_BITS_16, // YUV 4:4:4 16bit samples
  AVS_CS_YUV422P16 = ..., // AVS_CS_GENERIC_YUV422 | AVS_CS_SAMPLE_BITS_16, // YUV 4:2:2 16bit samples
  AVS_CS_YUV420P16 = ..., // AVS_CS_GENERIC_YUV420 | AVS_CS_SAMPLE_BITS_16, // YUV 4:2:0 16bit samples
  AVS_CS_Y16       = ..., // AVS_CS_GENERIC_Y | AVS_CS_SAMPLE_BITS_16,      // Y   4:0:0 16bit samples

  // 32 bit samples (float)
  AVS_CS_YUV444PS = ..., // AVS_CS_GENERIC_YUV444 | AVS_CS_SAMPLE_BITS_32,  // YUV 4:4:4 32bit samples
  AVS_CS_YUV422PS = ..., // AVS_CS_GENERIC_YUV422 | AVS_CS_SAMPLE_BITS_32,  // YUV 4:2:2 32bit samples
  AVS_CS_YUV420PS = ..., // AVS_CS_GENERIC_YUV420 | AVS_CS_SAMPLE_BITS_32,  // YUV 4:2:0 32bit samples
  AVS_CS_Y32      = ..., // AVS_CS_GENERIC_Y | AVS_CS_SAMPLE_BITS_32,       // Y   4:0:0 32bit samples

  // RGB packed
  AVS_CS_BGR48 = ..., // AVS_CS_RGB_TYPE | AVS_CS_BGR | AVS_CS_INTERLEAVED | AVS_CS_SAMPLE_BITS_16,    // BGR 3x16 bit
  AVS_CS_BGR64 = ..., // AVS_CS_RGBA_TYPE | AVS_CS_BGR | AVS_CS_INTERLEAVED | AVS_CS_SAMPLE_BITS_16,    // BGR 4x16 bit
  // no packed 32 bit (float) support for these legacy types

  // RGB planar
  AVS_CS_RGBP   = ..., // AVS_CS_GENERIC_RGBP | AVS_CS_SAMPLE_BITS_8,  // Planar RGB 8 bit samples
  AVS_CS_RGBP10 = ..., // AVS_CS_GENERIC_RGBP | AVS_CS_SAMPLE_BITS_10, // Planar RGB 10bit samples
  AVS_CS_RGBP12 = ..., // AVS_CS_GENERIC_RGBP | AVS_CS_SAMPLE_BITS_12, // Planar RGB 12bit samples
  AVS_CS_RGBP14 = ..., // AVS_CS_GENERIC_RGBP | AVS_CS_SAMPLE_BITS_14, // Planar RGB 14bit samples
  AVS_CS_RGBP16 = ..., // AVS_CS_GENERIC_RGBP | AVS_CS_SAMPLE_BITS_16, // Planar RGB 16bit samples
  AVS_CS_RGBPS  = ..., // AVS_CS_GENERIC_RGBP | AVS_CS_SAMPLE_BITS_32, // Planar RGB 32bit samples

  // RGBA planar
  AVS_CS_RGBAP   = ..., // AVS_CS_GENERIC_RGBAP | AVS_CS_SAMPLE_BITS_8,  // Planar RGBA 8 bit samples
  AVS_CS_RGBAP10 = ..., // AVS_CS_GENERIC_RGBAP | AVS_CS_SAMPLE_BITS_10, // Planar RGBA 10bit samples
  AVS_CS_RGBAP12 = ..., // AVS_CS_GENERIC_RGBAP | AVS_CS_SAMPLE_BITS_12, // Planar RGBA 12bit samples
  AVS_CS_RGBAP14 = ..., // AVS_CS_GENERIC_RGBAP | AVS_CS_SAMPLE_BITS_14, // Planar RGBA 14bit samples
  AVS_CS_RGBAP16 = ..., // AVS_CS_GENERIC_RGBAP | AVS_CS_SAMPLE_BITS_16, // Planar RGBA 16bit samples
  AVS_CS_RGBAPS  = ..., // AVS_CS_GENERIC_RGBAP | AVS_CS_SAMPLE_BITS_32, // Planar RGBA 32bit samples

  // Planar YUVA
  AVS_CS_YUVA444    = ..., // AVS_CS_GENERIC_YUVA444 | AVS_CS_SAMPLE_BITS_8,  // YUVA 4:4:4 8bit samples
  AVS_CS_YUVA422    = ..., // AVS_CS_GENERIC_YUVA422 | AVS_CS_SAMPLE_BITS_8,  // YUVA 4:2:2 8bit samples
  AVS_CS_YUVA420    = ..., // AVS_CS_GENERIC_YUVA420 | AVS_CS_SAMPLE_BITS_8,  // YUVA 4:2:0 8bit samples

  AVS_CS_YUVA444P10 = ..., // AVS_CS_GENERIC_YUVA444 | AVS_CS_SAMPLE_BITS_10, // YUVA 4:4:4 10bit samples
  AVS_CS_YUVA422P10 = ..., // AVS_CS_GENERIC_YUVA422 | AVS_CS_SAMPLE_BITS_10, // YUVA 4:2:2 10bit samples
  AVS_CS_YUVA420P10 = ..., // AVS_CS_GENERIC_YUVA420 | AVS_CS_SAMPLE_BITS_10, // YUVA 4:2:0 10bit samples

  AVS_CS_YUVA444P12 = ..., // AVS_CS_GENERIC_YUVA444 | AVS_CS_SAMPLE_BITS_12, // YUVA 4:4:4 12bit samples
  AVS_CS_YUVA422P12 = ..., // AVS_CS_GENERIC_YUVA422 | AVS_CS_SAMPLE_BITS_12, // YUVA 4:2:2 12bit samples
  AVS_CS_YUVA420P12 = ..., // AVS_CS_GENERIC_YUVA420 | AVS_CS_SAMPLE_BITS_12, // YUVA 4:2:0 12bit samples

  AVS_CS_YUVA444P14 = ..., // AVS_CS_GENERIC_YUVA444 | AVS_CS_SAMPLE_BITS_14, // YUVA 4:4:4 14bit samples
  AVS_CS_YUVA422P14 = ..., // AVS_CS_GENERIC_YUVA422 | AVS_CS_SAMPLE_BITS_14, // YUVA 4:2:2 14bit samples
  AVS_CS_YUVA420P14 = ..., // AVS_CS_GENERIC_YUVA420 | AVS_CS_SAMPLE_BITS_14, // YUVA 4:2:0 14bit samples

  AVS_CS_YUVA444P16 = ..., // AVS_CS_GENERIC_YUVA444 | AVS_CS_SAMPLE_BITS_16, // YUVA 4:4:4 16bit samples
  AVS_CS_YUVA422P16 = ..., // AVS_CS_GENERIC_YUVA422 | AVS_CS_SAMPLE_BITS_16, // YUVA 4:2:2 16bit samples
  AVS_CS_YUVA420P16 = ..., // AVS_CS_GENERIC_YUVA420 | AVS_CS_SAMPLE_BITS_16, // YUVA 4:2:0 16bit samples

  AVS_CS_YUVA444PS  = ..., // AVS_CS_GENERIC_YUVA444 | AVS_CS_SAMPLE_BITS_32,  // YUVA 4:4:4 32bit samples
  AVS_CS_YUVA422PS  = ..., // AVS_CS_GENERIC_YUVA422 | AVS_CS_SAMPLE_BITS_32,  // YUVA 4:2:2 32bit samples
  AVS_CS_YUVA420PS  = ...  // AVS_CS_GENERIC_YUVA420 | AVS_CS_SAMPLE_BITS_32,  // YUVA 4:2:0 32bit samples

};

enum {
  AVS_IT_BFF = ..., // 1<<0,
  AVS_IT_TFF = ..., // 1<<1,
  AVS_IT_FIELDBASED = ... // 1<<2
};

enum {
  AVS_FILTER_TYPE=1,
  AVS_FILTER_INPUT_COLORSPACE=2,
  AVS_FILTER_OUTPUT_TYPE=9,
  AVS_FILTER_NAME=4,
  AVS_FILTER_AUTHOR=5,
  AVS_FILTER_VERSION=6,
  AVS_FILTER_ARGS=7,
  AVS_FILTER_ARGS_INFO=8,
  AVS_FILTER_ARGS_DESCRIPTION=10,
  AVS_FILTER_DESCRIPTION=11};

enum {  //SUBTYPES
  AVS_FILTER_TYPE_AUDIO=1,
  AVS_FILTER_TYPE_VIDEO=2,
  AVS_FILTER_OUTPUT_TYPE_SAME=3,
  AVS_FILTER_OUTPUT_TYPE_DIFFERENT=4};

enum {
  // New 2.6 explicitly defined cache hints.
  AVS_CACHE_NOTHING=10, // Do not cache video.
  AVS_CACHE_WINDOW=11, // Hard protect upto X frames within a range of X from the current frame N.
  AVS_CACHE_GENERIC=12, // LRU cache upto X frames.
  AVS_CACHE_FORCE_GENERIC=13, // LRU cache upto X frames, override any previous CACHE_WINDOW.

  AVS_CACHE_GET_POLICY=30, // Get the current policy.
  AVS_CACHE_GET_WINDOW=31, // Get the current window h_span.
  AVS_CACHE_GET_RANGE=32, // Get the current generic frame range.

  AVS_CACHE_AUDIO=50, // Explicitly do cache audio, X byte cache.
  AVS_CACHE_AUDIO_NOTHING=51, // Explicitly do not cache audio.
  AVS_CACHE_AUDIO_NONE=52, // Audio cache off (auto mode), X byte intial cache.
  AVS_CACHE_AUDIO_AUTO=53, // Audio cache on (auto mode), X byte intial cache.

  AVS_CACHE_GET_AUDIO_POLICY=70, // Get the current audio policy.
  AVS_CACHE_GET_AUDIO_SIZE=71, // Get the current audio cache size.

  AVS_CACHE_PREFETCH_FRAME=100, // Queue request to prefetch frame N.
  AVS_CACHE_PREFETCH_GO=101, // Action video prefetches.

  AVS_CACHE_PREFETCH_AUDIO_BEGIN=120, // Begin queue request transaction to prefetch audio (take critical section).
  AVS_CACHE_PREFETCH_AUDIO_STARTLO=121, // Set low 32 bits of start.
  AVS_CACHE_PREFETCH_AUDIO_STARTHI=122, // Set high 32 bits of start.
  AVS_CACHE_PREFETCH_AUDIO_COUNT=123, // Set low 32 bits of length.
  AVS_CACHE_PREFETCH_AUDIO_COMMIT=124, // Enqueue request transaction to prefetch audio (release critical section).
  AVS_CACHE_PREFETCH_AUDIO_GO=125, // Action audio prefetches.

  AVS_CACHE_GETCHILD_CACHE_MODE=200, // Cache ask Child for desired video cache mode.
  AVS_CACHE_GETCHILD_CACHE_SIZE=201, // Cache ask Child for desired video cache size.
  AVS_CACHE_GETCHILD_AUDIO_MODE=202, // Cache ask Child for desired audio cache mode.
  AVS_CACHE_GETCHILD_AUDIO_SIZE=203, // Cache ask Child for desired audio cache size.

  AVS_CACHE_GETCHILD_COST=220, // Cache ask Child for estimated processing cost.
  AVS_CACHE_COST_ZERO=221, // Child response of zero cost (ptr arithmetic only).   AVS_CACHE_COST_UNIT=222, // Child response of unit cost (less than or equal 1 full frame blit).
  AVS_CACHE_COST_LOW=223, // Child response of light cost. (Fast)
  AVS_CACHE_COST_MED=224, // Child response of medium cost. (Real time)
  AVS_CACHE_COST_HI=225, // Child response of heavy cost. (Slow)

  AVS_CACHE_GETCHILD_THREAD_MODE=240, // Cache ask Child for thread safetyness.
  AVS_CACHE_THREAD_UNSAFE=241, // Only 1 thread allowed for all instances. 2.5 filters default!
  AVS_CACHE_THREAD_CLASS=242, // Only 1 thread allowed for each instance. 2.6 filters default!
  AVS_CACHE_THREAD_SAFE=243, //  Allow all threads in any instance.
  AVS_CACHE_THREAD_OWN=244, // Safe but limit to 1 thread, internally threaded.

  AVS_CACHE_GETCHILD_ACCESS_COST=260, // Cache ask Child for preferred access pattern.
  AVS_CACHE_ACCESS_RAND=261, // Filter is access order agnostic.
  AVS_CACHE_ACCESS_SEQ0=262, // Filter prefers sequential access (low cost)
  AVS_CACHE_ACCESS_SEQ1=263  // Filter needs sequential access (high cost)
  };


#define AVS_FRAME_ALIGN ...

typedef struct AVS_Clip AVS_Clip;
typedef struct AVS_ScriptEnvironment AVS_ScriptEnvironment;

/////////////////////////////////////////////////////////////////////
//
// AVS_VideoInfo
//

// AVS_VideoInfo is layed out identicly to VideoInfo
typedef struct AVS_VideoInfo {
  int width, height;    // width=0 means no video
  unsigned fps_numerator, fps_denominator;
  int num_frames;

  int pixel_type;
  
  int audio_samples_per_second;   // 0 means no audio
  int sample_type;
  INT64 num_audio_samples;
  int nchannels;

  // Imagetype properties

  int image_type;
} AVS_VideoInfo;

// useful functions of the above - functions with AVSC_INLINE
int avs_has_video(const AVS_VideoInfo * p);
int avs_has_audio(const AVS_VideoInfo * p);
int avs_is_rgb(const AVS_VideoInfo * p);
int avs_is_rgb24(const AVS_VideoInfo * p);
int avs_is_rgb32(const AVS_VideoInfo * p);
int avs_is_yuv(const AVS_VideoInfo * p);
int avs_is_yuy2(const AVS_VideoInfo * p);
// became a real interface function int avs_is_yv24(const AVS_VideoInfo * p);
// became a real interface function int avs_is_yv16(const AVS_VideoInfo * p);
// became a real interface function int avs_is_yv12(const AVS_VideoInfo * p);
// became a real interface function int avs_is_yv411(const AVS_VideoInfo * p);
// became a real interface function int avs_is_y8(const AVS_VideoInfo * p);
int avs_is_property(const AVS_VideoInfo * p, int property);
int avs_is_planar(const AVS_VideoInfo * p);
// became a real interface function int avs_is_color_space(const AVS_VideoInfo * p, int c_space);
int avs_is_field_based(const AVS_VideoInfo * p);
int avs_is_parity_known(const AVS_VideoInfo * p);
int avs_is_bff(const AVS_VideoInfo * p);
int avs_is_tff(const AVS_VideoInfo * p);
// became a real interface function int avs_bits_per_pixel(const AVS_VideoInfo * p);
// became a real interface function int avs_bytes_from_pixels(const AVS_VideoInfo * p, int pixels); // Will work on planar images, but will return only luma planes
// became a real interface function int avs_row_size(const AVS_VideoInfo * p);  // Also only returns first plane on planar images
// became a real interface function int avs_bmp_size(const AVS_VideoInfo * vi);
int avs_samples_per_second(const AVS_VideoInfo * p);
int avs_bytes_per_channel_sample(const AVS_VideoInfo * p);
int avs_bytes_per_audio_sample(const AVS_VideoInfo * p);
INT64 avs_audio_samples_from_frames(const AVS_VideoInfo * p, INT64 frames);
int avs_frames_from_audio_samples(const AVS_VideoInfo * p, INT64 samples);
INT64 avs_audio_samples_from_bytes(const AVS_VideoInfo * p, INT64 bytes);
INT64 avs_bytes_from_audio_samples(const AVS_VideoInfo * p, INT64 samples);
int avs_audio_channels(const AVS_VideoInfo * p);
int avs_sample_type(const AVS_VideoInfo * p);
void avs_set_property(AVS_VideoInfo * p, int property); // useful mutator
void avs_clear_property(AVS_VideoInfo * p, int property);
void avs_set_field_based(AVS_VideoInfo * p, int isfieldbased);
void avs_set_fps(AVS_VideoInfo * p, unsigned numerator, unsigned denominator);
// special: this inline function calls an API function
// Nevertheless it's not much use here, don't implement is
// int avs_is_same_colorspace(const AVS_VideoInfo * x, const AVS_VideoInfo * y);


/////////////////////////////////////////////////////////////////////
//
// AVS_VideoFrame
//

// VideoFrameBuffer holds information about a memory block which is used
// for video data.  For efficiency, instances of this class are not deleted
// when the refcount reaches zero; instead they're stored in a linked list
// to be reused.  The instances are deleted when the corresponding AVS
// file is closed.

// AVS_VideoFrameBuffer is layed out identicly to VideoFrameBuffer
// DO NOT USE THIS STRUCTURE DIRECTLY
typedef struct AVS_VideoFrameBuffer {
  BYTE * data;
  int data_size;
  // sequence_number is incremented every time the buffer is changed, so
  // that stale views can tell they're no longer valid.
  volatile long sequence_number;

  volatile long refcount;
} AVS_VideoFrameBuffer;

// VideoFrame holds a "window" into a VideoFrameBuffer.

// AVS_VideoFrame is layed out identicly to IVideoFrame
// DO NOT USE THIS STRUCTURE DIRECTLY
typedef struct AVS_VideoFrame {
  volatile long refcount;
  AVS_VideoFrameBuffer * vfb;
  int offset;
  int pitch, row_size, height;
  int offsetU, offsetV;
  int pitchUV;  // U&V offsets are from top of picture.
  int row_sizeUV, heightUV; // for Planar RGB offsetU, offsetV is for the 2nd and 3rd Plane.
                            // for Planar RGB pitchUV and row_sizeUV = 0, because when no VideoInfo (MakeWriteable)
                            // the decision on existance of UV is checked by zero pitch
  // AVS+ extension, avisynth.h: class does not break plugins if appended here
  int offsetA;
  int pitchA, row_sizeA; // 4th alpha plane support, pitch and row_size is 0 is none
} AVS_VideoFrame;


// Access functions for AVS_VideoFrame

// Special: this AVSC_INLINE is calling a real interface function
// int avs_get_pitch(const AVS_VideoFrame * p);

// became a real interface function
// int avs_get_pitch_p(const AVS_VideoFrame * p, int plane);

// Special: this AVSC_INLINE is calling a real interface function
// int avs_get_row_size(const AVS_VideoFrame * p);

// became a real interface function 
// int avs_get_row_size_p(const AVS_VideoFrame * p, int plane);

// Special: this AVSC_INLINE is calling a real interface function
// int avs_get_height(const AVS_VideoFrame * p);

// became a real interface function
// int avs_get_height_p(const AVS_VideoFrame * p, int plane);

// Special: this AVSC_INLINE is calling a real interface function
// const BYTE* avs_get_read_ptr(const AVS_VideoFrame * p);

// became a real interface function const BYTE* avs_get_read_ptr_p(const AVS_VideoFrame * p, int plane);
// int avs_is_writable(const AVS_VideoFrame * p);

// Special: this AVSC_INLINE is calling a real interface function
// BYTE* avs_get_write_ptr(const AVS_VideoFrame * p);

// became a real interface function
// BYTE* avs_get_write_ptr_p(const AVS_VideoFrame * p, int plane);


typedef void (*avs_release_video_frame_func)(AVS_VideoFrame *);
// makes a shallow copy of a video frame
typedef AVS_VideoFrame * (*avs_copy_video_frame_func)(AVS_VideoFrame *);

// ------------- currently done until this

/////////////////////////////////////////////////////////////////////
//
// AVS_Value
//

// Treat AVS_Value as a fat pointer.  That is use avs_copy_value
// and avs_release_value appropiaty as you would if AVS_Value was
// a pointer.

// To maintain source code compatibility with future versions of the
// avisynth_c API don't use the AVS_Value directly.  Use the helper
// functions below.

// AVS_Value is layed out identicly to AVSValue
typedef struct AVS_Value AVS_Value;
struct AVS_Value {
  short type;  // 'a'rray, 'c'lip, 'b'ool, 'i'nt, 'f'loat, 's'tring, 'v'oid, or 'l'ong
               // for some function e'rror
  short array_size;
  union {
    void * clip; // do not use directly, use avs_take_clip
    char boolean;
    int integer;
    float floating_pt;
    const char * string;
    const AVS_Value * array;
  } d;
};

// AVS_Value should be initilized with avs_void.
// Should also set to avs_void after the value is released
// with avs_copy_value.  Consider it the equalvent of setting
// a pointer to NULL
static const AVS_Value avs_void = {'v'};
static const AVS_Value * avs_void_p;

//typedef void (*avs_copy_value_func)(AVS_Value * dest, AVS_Value src);
void avs_copy_value_w(AVS_Value * dest, AVS_Value * src);
//typedef void (*avs_release_value_func)(AVS_Value);
void avs_release_value_w(AVS_Value *);

//int avs_defined(AVS_Value v);
int avs_defined_w(AVS_Value *v);
//int avs_is_clip(AVS_Value v);
int avs_is_clip_w(AVS_Value *v);
//int avs_is_bool(AVS_Value v);
int avs_is_bool_w(AVS_Value *v);
//int avs_is_int(AVS_Value v);
int avs_is_int_w(AVS_Value *v);
//int avs_is_float(AVS_Value v);
int avs_is_float_w(AVS_Value *v);
//int avs_is_string(AVS_Value v);
int avs_is_string_w(AVS_Value *v);
//int avs_is_array(AVS_Value v);
int avs_is_array_w(AVS_Value *v);
//int avs_is_error(AVS_Value v);
int avs_is_error_w(AVS_Value *v);

//typedef AVS_Clip * (*avs_take_clip_func)(AVS_Value, AVS_ScriptEnvironment *);
AVS_Clip * avs_take_clip_w(AVS_Value *, AVS_ScriptEnvironment *);
typedef void (*avs_set_to_clip_func)(AVS_Value *, AVS_Clip *);

//int avs_as_bool(AVS_Value v);
int avs_as_bool_w(AVS_Value *v);
//int avs_as_int(AVS_Value v);
int avs_as_int_w(AVS_Value *v);
//const char * avs_as_string(AVS_Value v);
const char * avs_as_string_w(AVS_Value *v);
//double avs_as_float(AVS_Value v);
double avs_as_float_w(AVS_Value *v);
//const char * avs_as_error(AVS_Value v);
const char * avs_as_error_w(AVS_Value *v);
//const AVS_Value * avs_as_array(AVS_Value v);
const AVS_Value * avs_as_array_w(AVS_Value *v);
//int avs_array_size(AVS_Value v);
int avs_array_size_w(AVS_Value *v);
//AVS_Value avs_array_elt(AVS_Value v, int index);
AVS_Value * avs_array_elt_w(AVS_Value *v, int index);

// only use these functions on an AVS_Value that does not already have
// an active value.  Remember, treat AVS_Value as a fat pointer.
//AVS_Value avs_new_value_bool(int v0);
void avs_new_value_bool_w(int v0, AVS_Value * v);
//AVS_Value avs_new_value_int(int v0);
void avs_new_value_int_w(int v0, AVS_Value * v);
//AVS_Value avs_new_value_string(const char * v0);
void avs_new_value_string_w(const char * v0, AVS_Value * v);
//AVS_Value avs_new_value_float(float v0);
void avs_new_value_float_w(float v0, AVS_Value * v);
//AVS_Value avs_new_value_error(const char * v0);
void avs_new_value_error_w(const char * v0, AVS_Value * v);
//AVS_Value avs_new_value_clip(AVS_Clip * v0);
void avs_new_value_clip_w(AVS_Clip * v0, AVS_Value * v);
//AVS_Value avs_new_value_array(AVS_Value * v0, int size);
void avs_new_value_array_w(AVS_Value * v0, int size, AVS_Value * v);


/////////////////////////////////////////////////////////////////////
//
// AVS_Clip
//

typedef void (*avs_release_clip_func)(AVS_Clip *);
typedef AVS_Clip * (*avs_copy_clip_func)(AVS_Clip *);

typedef const char * (*avs_clip_get_error_func)(AVS_Clip *); // return 0 if no error

typedef const AVS_VideoInfo * (*avs_get_video_info_func)(AVS_Clip *);

// new V6 Interface
typedef int (*avs_is_yv24_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_yv16_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_yv12_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_yv411_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_y8_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_color_space_func)(const AVS_VideoInfo * p, int c_space);
typedef int (*avs_get_plane_width_subsampling_func)(const AVS_VideoInfo * p, int plane);
typedef int (*avs_get_plane_height_subsampling_func)(const AVS_VideoInfo * p, int plane);
typedef int (*avs_bits_per_pixel_func)(const AVS_VideoInfo * p);
typedef int (*avs_bytes_from_pixels_func)(const AVS_VideoInfo * p, int pixels); // Will work on planar images, but will return only luma planes
typedef int (*avs_row_size_func)(const AVS_VideoInfo * p, int plane);  // Also only returns first plane on planar images. Fixed in V6: plane parameter
typedef int (*avs_bmp_size_func)(const AVS_VideoInfo * vi);
// Access functions for AVS_VideoFrame
typedef int (*avs_get_pitch_p_func)(const AVS_VideoFrame * p, int plane);
typedef int (*avs_get_row_size_p_func)(const AVS_VideoFrame * p, int plane);
typedef int (*avs_get_height_p_func)(const AVS_VideoFrame * p, int plane);
typedef const BYTE * (*avs_get_read_ptr_p_func)(const AVS_VideoFrame * p, int plane);
typedef int (*avs_is_writable_func)(const AVS_VideoFrame * p);
typedef BYTE * (*avs_get_write_ptr_p_func)(const AVS_VideoFrame * p, int plane);
// Avisynth+ extensions
typedef int (*avs_is_rgb48_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_rgb64_func)(const AVS_VideoInfo * p);
// AVSC_API(int, avs_is_yuv444p16)(const AVS_VideoInfo * p); // obsolate, use avs_is_yuv444
// AVSC_API(int, avs_is_yuv422p16)(const AVS_VideoInfo * p); // obsolate, use avs_is_yuv422
// AVSC_API(int, avs_is_yuv420p16)(const AVS_VideoInfo * p); // obsolate, use avs_is_yuv420
// AVSC_API(int, avs_is_y16)(const AVS_VideoInfo * p); // obsolate, use avs_is_y
// AVSC_API(int, avs_is_yuv444ps)(const AVS_VideoInfo * p); // obsolate, use avs_is_yuv444
// AVSC_API(int, avs_is_yuv422ps)(const AVS_VideoInfo * p); // obsolate, use avs_is_yuv422
// AVSC_API(int, avs_is_yuv420ps)(const AVS_VideoInfo * p); // obsolate, use avs_is_yuv420
// AVSC_API(int, avs_is_y32)(const AVS_VideoInfo * p); // obsolate, use avs_is_y
typedef int (*avs_is_444_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_422_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_420_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_y_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_yuva_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_planar_rgb_func)(const AVS_VideoInfo * p);
typedef int (*avs_is_planar_rgba_func)(const AVS_VideoInfo * p);
typedef int (*avs_num_components_func)(const AVS_VideoInfo * p);
typedef int (*avs_component_size_func)(const AVS_VideoInfo * p);
typedef int (*avs_bits_per_component_func)(const AVS_VideoInfo * p);
// end of Avisynth+ specific


typedef int (*avs_get_version_func)(AVS_Clip *);
 
typedef AVS_VideoFrame * (*avs_get_frame_func)(AVS_Clip *, int n);
// The returned video frame must be released with avs_release_video_frame

typedef int (*avs_get_parity_func)(AVS_Clip *, int n); 
// return field parity if field_based, else parity of first field in frame

typedef int (*avs_get_audio_func)(AVS_Clip *, void * buf, 
                             INT64 start, INT64 count); 
// start and count are in samples

typedef int (*avs_set_cache_hints_func)(AVS_Clip *, 
                                   int cachehints, int frame_range);

// XXX: AVS_ApplyFunc left out


// XXX: AVS_FilterInfo left out

// Create a new filter
// fi is set to point to the AVS_FilterInfo so that you can
//   modify it once it is initilized.
// store_child should generally be set to true.  If it is not
//    set than ALL methods (the function pointers) must be defined
// If it is set than you do not need to worry about freeing the child
//    clip.
typedef AVS_Clip * (*avs_new_c_filter_func)(AVS_ScriptEnvironment * e,
                                       void * * fi,
                                       void * child, int store_child);


/////////////////////////////////////////////////////////////////////
//
// AVS_ScriptEnvironment
//

enum {
                                /* slowest CPU to support extension */
  AVS_CPU_FORCE        = 0x01,   // N/A
  AVS_CPU_FPU          = 0x02,   // 386/486DX
  AVS_CPU_MMX          = 0x04,   // P55C, K6, PII
  AVS_CPU_INTEGER_SSE  = 0x08,   // PIII, Athlon
  AVS_CPU_SSE          = 0x10,   // PIII, Athlon XP/MP
  AVS_CPU_SSE2         = 0x20,   // PIV, Hammer
  AVS_CPU_3DNOW        = 0x40,   // K6-2
  AVS_CPU_3DNOW_EXT    = 0x80,   // Athlon
  AVS_CPU_X86_64       = 0xA0,   // Hammer (note: equiv. to 3DNow + SSE2,
                                 // which only Hammer will have anyway)
  AVS_CPUF_SSE3       = 0x100,   //  PIV+, K8 Venice
  AVS_CPUF_SSSE3      = 0x200,   //  Core 2
  AVS_CPUF_SSE4       = 0x400,   //  Penryn, Wolfdale, Yorkfield
  AVS_CPUF_SSE4_1     = 0x400,
  AVS_CPUF_AVX        = 0x800,   //  Sandy Bridge, Bulldozer
  AVS_CPUF_SSE4_2    = 0x1000,   //  Nehalem
  // AVS+
  AVS_CPUF_AVX2      = 0x2000,   //  Haswell
  AVS_CPUF_FMA3      = 0x4000,
  AVS_CPUF_F16C      = 0x8000,
  AVS_CPUF_MOVBE     = 0x10000,   // Big Endian Move
  AVS_CPUF_POPCNT    = 0x20000,
  AVS_CPUF_AES       = 0x40000,
  AVS_CPUF_FMA4      = 0x80000,

  AVS_CPUF_AVX512F    = 0x100000,  // AVX-512 Foundation.
  AVS_CPUF_AVX512DQ   = 0x200000,  // AVX-512 DQ (Double/Quad granular) Instructions
  AVS_CPUF_AVX512PF   = 0x400000,  // AVX-512 Prefetch
  AVS_CPUF_AVX512ER   = 0x800000,  // AVX-512 Exponential and Reciprocal
  AVS_CPUF_AVX512CD   = 0x1000000, // AVX-512 Conflict Detection
  AVS_CPUF_AVX512BW   = 0x2000000, // AVX-512 BW (Byte/Word granular) Instructions
  AVS_CPUF_AVX512VL   = 0x4000000, // AVX-512 VL (128/256 Vector Length) Extensions
  AVS_CPUF_AVX512IFMA = 0x8000000, // AVX-512 IFMA integer 52 bit
  AVS_CPUF_AVX512VBMI = 0x10000000 // AVX-512 VBMI
};

typedef const char * (*avs_get_error_func)(AVS_ScriptEnvironment *); // return 0 if no error

typedef long (*avs_get_cpu_flags_func)(AVS_ScriptEnvironment *);
typedef int (*avs_check_version_func)(AVS_ScriptEnvironment *, int version);

typedef char * (*avs_save_string_func)(AVS_ScriptEnvironment *, const char* s, int length);
typedef char * (*avs_sprintf_func)(AVS_ScriptEnvironment *, const char * fmt, ...);

typedef char * (*avs_vsprintf_func)(AVS_ScriptEnvironment *, const char * fmt, void* val);
 // note: val is really a va_list; I hope everyone typedefs va_list to a pointer

typedef int (*avs_add_function_func)(AVS_ScriptEnvironment *, 
                                const char * name, const char * params, 
                                void * apply, void * user_data);


typedef int (*avs_function_exists_func)(AVS_ScriptEnvironment *, const char * name);

//typedef AVS_Value (*avs_invoke_func)(AVS_ScriptEnvironment *, const char * name, AVS_Value args, const char** arg_names);
void avs_invoke_w(AVS_ScriptEnvironment *, const char * name, AVS_Value *args, const char** arg_names, AVS_Value *v);
// The returned value must be be released with avs_release_value

//typedef AVS_Value (*avs_get_var_func)(AVS_ScriptEnvironment *, const char* name);
void avs_get_var_w(AVS_ScriptEnvironment *env, const char* name, AVS_Value* v);
// The returned value must be be released with avs_release_value

//typedef int (*avs_set_var_func)(AVS_ScriptEnvironment *, const char* name, AVS_Value val);
int avs_set_var_w(AVS_ScriptEnvironment *, const char* name, AVS_Value* val);

//typedef int (*avs_set_global_var_func)(AVS_ScriptEnvironment *, const char* name, AVS_Value val);
int avs_set_global_var_w(AVS_ScriptEnvironment *, const char* name, const AVS_Value* val);

//void avs_push_context(AVS_ScriptEnvironment *, int level=0);
//void avs_pop_context(AVS_ScriptEnvironment *);

typedef AVS_VideoFrame * (*avs_new_video_frame_a_func)(AVS_ScriptEnvironment *, 
                                          const AVS_VideoInfo * vi, int align);

typedef int (*avs_make_writable_func)(AVS_ScriptEnvironment *, AVS_VideoFrame * * pvf);

typedef void (*avs_bit_blt_func)(AVS_ScriptEnvironment *, BYTE* dstp, int dst_pitch, const BYTE* srcp, int src_pitch, int row_size, int height);

typedef void (*AVS_ShutdownFunc)(void* user_data, AVS_ScriptEnvironment * env);
typedef void (*avs_at_exit_func)(AVS_ScriptEnvironment *, AVS_ShutdownFunc function, void * user_data);

typedef AVS_VideoFrame * (*avs_subframe_func)(AVS_ScriptEnvironment *, AVS_VideoFrame * src, int rel_offset, int new_pitch, int new_row_size, int new_height);
// The returned video frame must be be released

typedef int (*avs_set_memory_max_func)(AVS_ScriptEnvironment *, int mem);

typedef int (*avs_set_working_dir_func)(AVS_ScriptEnvironment *, const char * newdir);

// avisynth.dll exports this; it's a way to use it as a library, without
// writing an AVS script or without going through AVIFile.
typedef AVS_ScriptEnvironment * (*avs_create_script_environment_func)(int version);


typedef void (*avs_delete_script_environment_func)(AVS_ScriptEnvironment *);


typedef AVS_VideoFrame * (*avs_subframe_planar_func)(AVS_ScriptEnvironment *, AVS_VideoFrame * src, int rel_offset, int new_pitch, int new_row_size, int new_height, int rel_offsetU, int rel_offsetV, int new_pitchUV);
// The returned video frame must be be released


void* malloc(size_t);
void free(void*);

HMODULE LoadLibrary(const char*);
void* GetProcAddress(HMODULE, const char*);
void FreeLibrary(HMODULE);

typedef struct AVS_Library{ ...; } AVS_Library;

// this section appears twice, see also in verify_str
avs_add_function_func avs_add_function;
avs_at_exit_func avs_at_exit;
avs_bit_blt_func avs_bit_blt;
avs_check_version_func avs_check_version;
avs_clip_get_error_func avs_clip_get_error;
// avs_copy_value_func avs_copy_value; // No! Has wrapper function
avs_copy_clip_func avs_copy_clip;
avs_copy_video_frame_func avs_copy_video_frame;
avs_create_script_environment_func avs_create_script_environment;
avs_delete_script_environment_func avs_delete_script_environment;
avs_function_exists_func avs_function_exists;
avs_get_audio_func avs_get_audio;
avs_get_cpu_flags_func avs_get_cpu_flags;
avs_get_frame_func avs_get_frame;
avs_get_parity_func avs_get_parity;
// avs_get_var_func avs_get_var; // // No! Has wrapper function
avs_get_version_func avs_get_version;
avs_get_video_info_func avs_get_video_info;
// avs_invoke_func avs_invoke; // No! Has wrapper function
avs_make_writable_func avs_make_writable;
avs_new_c_filter_func avs_new_c_filter;
avs_new_video_frame_a_func avs_new_video_frame_a;
avs_release_clip_func avs_release_clip;
// avs_release_value_func avs_release_value; // No! Has wrapper function
avs_release_video_frame_func avs_release_video_frame;
avs_save_string_func avs_save_string;
avs_set_cache_hints_func avs_set_cache_hints;
// avs_set_global_var_func avs_set_global_var; // No! Has wrapper function
avs_set_memory_max_func avs_set_memory_max;
avs_set_to_clip_func avs_set_to_clip; // NEW! todo check its usage
// avs_set_var_func avs_set_var; // No! Has wrapper function
avs_set_working_dir_func avs_set_working_dir;
avs_sprintf_func avs_sprintf;
avs_subframe_func avs_subframe;
avs_subframe_planar_func avs_subframe_planar;
// avs_take_clip_func avs_take_clip; // No! Has wrapper function
avs_vsprintf_func avs_vsprintf;

avs_get_error_func avs_get_error;
// new V6
avs_is_yv24_func avs_is_yv24;
avs_is_yv16_func avs_is_yv16;
avs_is_yv12_func avs_is_yv12;
avs_is_yv411_func avs_is_yv411;
avs_is_y8_func avs_is_y8;
avs_is_color_space_func avs_is_color_space;

avs_get_plane_width_subsampling_func avs_get_plane_width_subsampling;
avs_get_plane_height_subsampling_func avs_get_plane_height_subsampling;
avs_bits_per_pixel_func avs_bits_per_pixel;
avs_bytes_from_pixels_func avs_bytes_from_pixels;
avs_row_size_func avs_row_size;
avs_bmp_size_func avs_bmp_size;
avs_get_pitch_p_func avs_get_pitch_p;
avs_get_row_size_p_func avs_get_row_size_p;
avs_get_height_p_func avs_get_height_p;
avs_get_read_ptr_p_func avs_get_read_ptr_p;
avs_is_writable_func avs_is_writable;
avs_get_write_ptr_p_func avs_get_write_ptr_p;

// Avisynth+ specific
avs_is_rgb48_func avs_is_rgb48;
avs_is_rgb64_func avs_is_rgb64;
//some obsolate function
//AVSC_DECLARE_FUNC(avs_is_yuv444p16);
//AVSC_DECLARE_FUNC(avs_is_yuv422p16);
//AVSC_DECLARE_FUNC(avs_is_yuv420p16);
//AVSC_DECLARE_FUNC(avs_is_y16);
//AVSC_DECLARE_FUNC(avs_is_yuv444ps);
//AVSC_DECLARE_FUNC(avs_is_yuv422ps);
//AVSC_DECLARE_FUNC(avs_is_yuv420ps);
//AVSC_DECLARE_FUNC(avs_is_y32);
avs_is_444_func avs_is_444;
avs_is_422_func avs_is_422;
avs_is_420_func avs_is_420;
avs_is_y_func avs_is_y;
avs_is_yuva_func avs_is_yuva;
avs_is_planar_rgb_func avs_is_planar_rgb;
avs_is_planar_rgba_func avs_is_planar_rgba;
avs_num_components_func avs_num_components;
avs_component_size_func avs_component_size;
avs_bits_per_component_func avs_bits_per_component;
// end of Avisynth+ specific

;AVS_Library * avs_load_library();
AVS_Library * avs_load_library_w();
void avs_free_library(AVS_Library *library);

AVS_Library * library;
"""

verify_str = r"""
#pragma warning(disable: 4028 4047) // because of the function ptr hack
#include <windows.h>
#define AVSC_NO_DECLSPEC
#include "avisynth_c.h"

AVS_Library * library;

static const AVS_Value * avs_void_p = &avs_void;


// no wrapper needed for the following functions

avs_add_function_func avs_add_function;
avs_at_exit_func avs_at_exit;
avs_bit_blt_func avs_bit_blt;
avs_check_version_func avs_check_version;
avs_clip_get_error_func avs_clip_get_error;
// avs_copy_value_func avs_copy_value; // No! Has wrapper function
avs_copy_clip_func avs_copy_clip;
avs_copy_video_frame_func avs_copy_video_frame;
avs_create_script_environment_func avs_create_script_environment;
avs_delete_script_environment_func avs_delete_script_environment;
avs_function_exists_func avs_function_exists;
avs_get_audio_func avs_get_audio;
avs_get_cpu_flags_func avs_get_cpu_flags;
avs_get_frame_func avs_get_frame;
avs_get_parity_func avs_get_parity;
// avs_get_var_func avs_get_var; // // No! Has wrapper function
avs_get_version_func avs_get_version;
avs_get_video_info_func avs_get_video_info;
// avs_invoke_func avs_invoke; // No! Has wrapper function
avs_make_writable_func avs_make_writable;
avs_new_c_filter_func avs_new_c_filter;
avs_new_video_frame_a_func avs_new_video_frame_a;
avs_release_clip_func avs_release_clip;
// avs_release_value_func avs_release_value; // No! Has wrapper function
avs_release_video_frame_func avs_release_video_frame;
avs_save_string_func avs_save_string;
avs_set_cache_hints_func avs_set_cache_hints;
// avs_set_global_var_func avs_set_global_var; // No! Has wrapper function
avs_set_memory_max_func avs_set_memory_max;
avs_set_to_clip_func avs_set_to_clip; // NEW! todo check its usage
// avs_set_var_func avs_set_var; // No! Has wrapper function
avs_set_working_dir_func avs_set_working_dir;
avs_sprintf_func avs_sprintf;
avs_subframe_func avs_subframe;
avs_subframe_planar_func avs_subframe_planar;
// avs_take_clip_func avs_take_clip; // No! Has wrapper function
avs_vsprintf_func avs_vsprintf;

avs_get_error_func avs_get_error;
// new V6
avs_is_yv24_func avs_is_yv24;
avs_is_yv16_func avs_is_yv16;
avs_is_yv12_func avs_is_yv12;
avs_is_yv411_func avs_is_yv411;
avs_is_y8_func avs_is_y8;
avs_is_color_space_func avs_is_color_space;

avs_get_plane_width_subsampling_func avs_get_plane_width_subsampling;
avs_get_plane_height_subsampling_func avs_get_plane_height_subsampling;
avs_bits_per_pixel_func avs_bits_per_pixel;
avs_bytes_from_pixels_func avs_bytes_from_pixels;
avs_row_size_func avs_row_size;
avs_bmp_size_func avs_bmp_size;
avs_get_pitch_p_func avs_get_pitch_p;
avs_get_row_size_p_func avs_get_row_size_p;
avs_get_height_p_func avs_get_height_p;
avs_get_read_ptr_p_func avs_get_read_ptr_p;
avs_is_writable_func avs_is_writable;
avs_get_write_ptr_p_func avs_get_write_ptr_p;

// Avisynth+ specific
avs_is_rgb48_func avs_is_rgb48;
avs_is_rgb64_func avs_is_rgb64;
//some obsolate function
//AVSC_DECLARE_FUNC(avs_is_yuv444p16);
//AVSC_DECLARE_FUNC(avs_is_yuv422p16);
//AVSC_DECLARE_FUNC(avs_is_yuv420p16);
//AVSC_DECLARE_FUNC(avs_is_y16);
//AVSC_DECLARE_FUNC(avs_is_yuv444ps);
//AVSC_DECLARE_FUNC(avs_is_yuv422ps);
//AVSC_DECLARE_FUNC(avs_is_yuv420ps);
//AVSC_DECLARE_FUNC(avs_is_y32);
avs_is_444_func avs_is_444;
avs_is_422_func avs_is_422;
avs_is_420_func avs_is_420;
avs_is_y_func avs_is_y;
avs_is_yuva_func avs_is_yuva;
avs_is_planar_rgb_func avs_is_planar_rgb;
avs_is_planar_rgba_func avs_is_planar_rgba;
avs_num_components_func avs_num_components;
avs_component_size_func avs_component_size;
avs_bits_per_component_func avs_bits_per_component;
// end of Avisynth+ specific

AVS_Library * avs_load_library_w(){
    library = avs_load_library();
    avs_add_function=library->avs_add_function;
    avs_at_exit=library->avs_at_exit;
    avs_bit_blt=library->avs_bit_blt;
    avs_check_version=library->avs_check_version;
    avs_clip_get_error=library->avs_clip_get_error;
    // avs_copy_value=library->avs_copy_value; // No! Has wrapper function
    avs_copy_clip=library->avs_copy_clip;
    avs_copy_video_frame=library->avs_copy_video_frame;
    avs_create_script_environment=library->avs_create_script_environment;
    avs_function_exists=library->avs_function_exists;
    avs_delete_script_environment=library->avs_delete_script_environment;
    avs_get_audio=library->avs_get_audio;
    avs_get_cpu_flags=library->avs_get_cpu_flags;
    avs_get_frame=library->avs_get_frame;
    avs_get_parity=library->avs_get_parity;
    // avs_get_var=library->avs_get_var; // // No! Has wrapper function
    avs_get_version=library->avs_get_version;
    avs_get_video_info=library->avs_get_video_info;
    // avs_invoke=library->avs_invoke; // No! Has wrapper function
    avs_make_writable=library->avs_make_writable;
    avs_new_c_filter=library->avs_new_c_filter;
    avs_new_video_frame_a=library->avs_new_video_frame_a;
    avs_release_clip=library->avs_release_clip;
    // avs_release_value=library->avs_release_value; // No! Has wrapper function
    avs_release_video_frame=library->avs_release_video_frame;
    avs_save_string=library->avs_save_string;
    avs_set_cache_hints=library->avs_set_cache_hints;
    // avs_set_global_var=library->avs_set_global_var; // No! Has wrapper function
    avs_set_memory_max=library->avs_set_memory_max;
    avs_set_to_clip=library->avs_set_to_clip; // NEW! todo check its usage
    // avs_set_var=library->avs_set_var; // No! Has wrapper function
    avs_set_working_dir=library->avs_set_working_dir;
    avs_sprintf=library->avs_sprintf;
    avs_subframe=library->avs_subframe;
    avs_subframe_planar=library->avs_subframe_planar;
    // avs_take_clip=library->avs_take_clip; // No! Has wrapper function
    avs_vsprintf=library->avs_vsprintf;
    avs_get_error=library->avs_get_error;
    // new V6
    avs_is_yv24=library->avs_is_yv24;
    avs_is_yv16=library->avs_is_yv16;
    avs_is_yv12=library->avs_is_yv12;
    avs_is_yv411=library->avs_is_yv411;
    avs_is_y8=library->avs_is_y8;
    avs_is_color_space=library->avs_is_color_space;

    avs_get_plane_width_subsampling=library->avs_get_plane_width_subsampling;
    avs_get_plane_height_subsampling=library->avs_get_plane_height_subsampling;
    avs_bits_per_pixel=library->avs_bits_per_pixel;
    avs_bytes_from_pixels=library->avs_bytes_from_pixels;
    avs_row_size=library->avs_row_size;
    avs_bmp_size=library->avs_bmp_size;
    avs_get_pitch_p=library->avs_get_pitch_p;
    avs_get_row_size_p=library->avs_get_row_size_p;
    avs_get_height_p=library->avs_get_height_p;
    avs_get_read_ptr_p=library->avs_get_read_ptr_p;
    avs_is_writable=library->avs_is_writable;
    avs_get_write_ptr_p=library->avs_get_write_ptr_p;

    // Avisynth+ specific
    avs_is_rgb48=library->avs_is_rgb48;
    avs_is_rgb64=library->avs_is_rgb64;
    //some obsolate function
    //AVSC_DECLARE_FUNC(avs_is_yuv444p16);
    //AVSC_DECLARE_FUNC(avs_is_yuv422p16);
    //AVSC_DECLARE_FUNC(avs_is_yuv420p16);
    //AVSC_DECLARE_FUNC(avs_is_y16);
    //AVSC_DECLARE_FUNC(avs_is_yuv444ps);
    //AVSC_DECLARE_FUNC(avs_is_yuv422ps);
    //AVSC_DECLARE_FUNC(avs_is_yuv420ps);
    //AVSC_DECLARE_FUNC(avs_is_y32);
    avs_is_444=library->avs_is_444;
    avs_is_422=library->avs_is_422;
    avs_is_420=library->avs_is_420;
    avs_is_y=library->avs_is_y;
    avs_is_yuva=library->avs_is_yuva;
    avs_is_planar_rgb=library->avs_is_planar_rgb;
    avs_is_planar_rgba=library->avs_is_planar_rgba;
    avs_num_components=library->avs_num_components;
    avs_component_size=library->avs_component_size;
    avs_bits_per_component=library->avs_bits_per_component;
    // end of Avisynth+ specific
    return library;
}

// wrapped functions


// AVS_Value

void avs_copy_value_w(AVS_Value * dest, AVS_Value * src){
    library->avs_copy_value(dest, *src);
}
void avs_release_value_w(AVS_Value *value){
    library->avs_release_value(*value);
}

int avs_defined_w(AVS_Value *v){return avs_defined(*v);}
int avs_is_clip_w(AVS_Value *v){return avs_is_clip(*v);}
int avs_is_bool_w(AVS_Value *v){return avs_is_bool(*v);}
int avs_is_int_w(AVS_Value *v){return avs_is_int(*v);}
int avs_is_float_w(AVS_Value *v){return avs_is_float(*v);}
int avs_is_string_w(AVS_Value *v){return avs_is_string(*v);}
int avs_is_array_w(AVS_Value *v){return avs_is_array(*v);}
int avs_is_error_w(AVS_Value *v){return avs_is_error(*v);}

AVS_Clip * avs_take_clip_w(AVS_Value *val, AVS_ScriptEnvironment *env){
    return library->avs_take_clip(*val, env);
}

int avs_as_bool_w(AVS_Value *v){return avs_as_bool(*v);}
int avs_as_int_w(AVS_Value *v){return avs_as_int(*v);}
const char * avs_as_string_w(AVS_Value *v){return avs_as_string(*v);}
double avs_as_float_w(AVS_Value *v){return avs_as_float(*v);}
const char * avs_as_error_w(AVS_Value *v){return avs_as_error(*v);}
const AVS_Value * avs_as_array_w(AVS_Value *v){return avs_as_array(*v);}
int avs_array_size_w(AVS_Value *v){return avs_array_size(*v);}
AVS_Value * avs_array_elt_w(AVS_Value *v, int index){
    return avs_is_array(*v)? &((*v).d.array[index]): v;
}


// AVS_ScriptEnvironment

void avs_invoke_w(AVS_ScriptEnvironment *env, const char * name, 
                  AVS_Value *args, const char** arg_names, AVS_Value *val){
    AVS_Value ret = library->avs_invoke(env, name, *args, arg_names);
    library->avs_copy_value(val, ret);
    library->avs_release_value(ret);
    library->avs_copy_value(&ret, avs_void);
}

void avs_get_var_w(AVS_ScriptEnvironment *env, const char* name, AVS_Value* val){
    AVS_Value ret = library->avs_get_var(env, name);
    library->avs_copy_value(val, ret);
    library->avs_release_value(ret);
    library->avs_copy_value(&ret, avs_void);
}
int avs_set_var_w(AVS_ScriptEnvironment *env, const char* name, AVS_Value* val){
    return library->avs_set_var(env, name, *val);
}
int avs_set_global_var_w(AVS_ScriptEnvironment *env, const char* name, 
                         const AVS_Value* val){
    return library->avs_set_global_var(env, name, *val);
}

void avs_new_value_bool_w(int v0, AVS_Value * v){
    (*v).type = 'b'; 
    (*v).d.boolean = v0 == 0 ? 0 : 1;
}   
void avs_new_value_int_w(int v0, AVS_Value * v){
    (*v).type = 'i'; 
    (*v).d.integer = v0;
}   
void avs_new_value_string_w(const char * v0, AVS_Value * v){
    (*v).type = 's'; 
    (*v).d.string = v0;
}   
void avs_new_value_float_w(float v0, AVS_Value * v){
    (*v).type = 'f'; 
    (*v).d.floating_pt = v0;
}   
void avs_new_value_error_w(const char * v0, AVS_Value * v){
    (*v).type = 'e'; 
    (*v).d.string = v0;
}   
void avs_new_value_clip_w(AVS_Clip * v0, AVS_Value * v){
    library->avs_set_to_clip(v, v0);
}
void avs_new_value_array_w(AVS_Value * v0, int size, AVS_Value * v){
    (*v).type = 'a'; 
    (*v).d.array = v0;
    (*v).array_size = size;
}   

"""

ffi = cffi.FFI()
ffi.cdef(cdef_str)
if abi: # TODO
    avs = ffi.dlopen('avisynth')
else:
    avs = ffi.verify(verify_str, libraries=[], library_dirs=[],
        modulename=os.path.splitext(__file__)[0] + '_ext', # comment out on debugging
        )
    avs.library = avs.avs_load_library_w()

class AVS_VideoInfo(object):
    
    def __init__(self, vi=None):
        self.cdata = vi or ffi.new('AVS_VideoInfo *')
        for field, value in ffi.typeof(self.cdata[0]).fields:
            setattr(self, field, getattr(self.cdata, field))
    
    def __str__(self):
        string = str(self.__class__)
        for field, value in ffi.typeof(self.cdata[0]).fields:
            string += ', {0}: {1}'.format(field, getattr(self.cdata, field))
        return string
    
    def has_video(self):
        return avs.avs_has_video(self.cdata)
    
    def has_audio(self):
        return avs.avs_has_audio(self.cdata)
    
    def is_rgb(self):
        return bool(avs.avs_is_rgb(self.cdata))
    
    def is_rgb24(self):
        return bool(avs.avs_is_rgb24(self.cdata))
    
    def is_rgb32(self):
        return bool(avs.avs_is_rgb32(self.cdata))
    
    def is_yuv(self):
        return bool(avs.avs_is_yuv(self.cdata))
    
    def is_yuy2(self):
        return bool(avs.avs_is_yuy2(self.cdata))
    
    def is_yv24(self):
        return bool(avs.avs_is_yv24(self.cdata))
    
    def is_yv16(self):
        return bool(avs.avs_is_yv16(self.cdata))
    
    def is_yv12(self):
        return bool(avs.avs_is_yv12(self.cdata))
    
    def is_yv411(self):
        return bool(avs.avs_is_yv411(self.cdata))
    
    def is_y8(self):
        return bool(avs.avs_is_y8(self.cdata))
    
    def is_property(self, property):
        return bool(avs.avs_is_yuy2(self.cdata, property))
    
    def is_planar(self):
        return bool(avs.avs_is_planar(self.cdata))
    
    def is_color_space(self, color_space):
        return bool(avs.avs_is_color_space(self.cdata, color_space))
    
    def is_field_based(self):
        return bool(avs.avs_is_field_based(self.cdata))
    
    def is_parity_known(self):
        return bool(avs.avs_is_parity_known(self.cdata))
    
    def is_bff(self):
        return bool(avs.avs_is_bff(self.cdata))
    
    def is_tff(self):
        return bool(avs.avs_is_tff(self.cdata))
    
    def is_v_plane_first(self): # interface.cpp
        return not self.is_y8() and self.is_planar() and (self.pixel_type & \
            (avs.AVS_CS_VPLANEFIRST | avs.AVS_CS_UPLANEFIRST)) \
            == avs.AVS_CS_VPLANEFIRST # Shouldn't use this
    
    def get_plane_width_subsampling(self, plane): # interface.cpp
        return avs.avs_get_plane_width_subsampling(self.cdata, plane);
        # IF V6: became and interface fn
    
    def get_plane_height_subsampling(self, plane): # interface.cpp
        return avs.avs_get_plane_height_subsampling(self.cdata, plane);
        # IF V6: became and interface fn
    
    def bits_per_pixel(self):
        return avs.avs_bits_per_pixel(self.cdata)
    
    def bytes_from_pixels(self, pixels):
        # Will work on planar images, but will return only luma planes
        return avs.avs_bytes_from_pixels(self.cdata, pixels)
    
    def row_size(self):
        # Also only returns first plane on planar images
        return avs.avs_row_size(self.cdata)
    
    def bmp_size(self):
        return avs.avs_bmp_size(self.cdata)
    
    def samples_per_second(self):
        return avs.avs_samples_per_second(self.cdata)
    
    def is_sample_type(self, testtype): # interface.cpp
        return (self.cdata.sample_type & testtype) != 0
    
    def bytes_per_channel_sample(self):
        return avs.avs_bytes_per_channel_sample(self.cdata)
    
    def bytes_per_audio_sample(self):
        return avs.avs_bytes_per_audio_sample(self.cdata)
    
    def audio_samples_from_frames(self, frames):
        return avs.avs_audio_samples_from_frames(self.cdata, frames)
    
    def frames_from_audio_samples(self, samples):
        return avs.avs_frames_from_audio_samples(self.cdata, samples)
    
    def audio_samples_from_bytes(self, bytes):
        return avs.avs_audio_samples_from_bytes(self.cdata, bytes)
    
    def bytes_from_audio_samples(self, samples):
        return avs.avs_bytes_from_audio_samples(self.cdata, samples)
    
    def audio_channels(self):
        return avs.avs_audio_channels(self.cdata)
    
    def sample_type(self):
        return avs.avs_sample_type(self.cdata)
    
    def set_property(self, property):
        # useful mutator
        avs.avs_set_property(self.cdata, property)
    
    def clear_property(self, property):
        avs.avs_clear_property(self.cdata, property)
    
    def set_field_based(self, is_field_based):
        avs.avs_set_field_based(self.cdata, is_field_based)
    
    def set_fps(self, numerator, denominator):
        avs.avs_set_fps(self.cdata, numerator, denominator)
'''
    # left out intentionally
    def is_same_colorspace(self, vi):
        return bool(avs.avs_is_same_colorspace(self.cdata, vi))
'''

class AVS_VideoFrame(object):
    
    def __init__(self, vf):
        self.cdata = vf
    
    def __del__(self):
        avs.avs_release_video_frame(self.cdata)
    
    def copy(self):
        """makes a shallow copy of a video frame"""
        return avs.avs_copy_video_frame(self.cdata)
    
    def __str__(self):
        string = str(self.__class__)
        for field, value in ffi.typeof(self.cdata[0]).fields:
            string += ', {0}: {1}'.format(field, getattr(self.cdata, field))
        return string
    
    def get_pitch(self, plane=avs.AVS_PLANAR_Y):
        # U&V offsets are from top of picture
        return avs.avs_get_pitch_p(self.cdata, plane)
    
    def get_row_size(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_row_size_p(self.cdata, plane)
    
    def get_height(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_height_p(self.cdata, plane)
    
    def get_frame_buffer(self): # interface.cpp
        return self.cdata.vfb
    
    # not nice. Accessing the internal fields directly despite the big warning:
    # // DO NOT USE THIS STRUCTURE DIRECTLY
    def get_offset(self, plane=avs.AVS_PLANAR_Y): # interface.cpp
        if plane == avs.AVS_PLANAR_U: return self.cdata.offsetU
        elif plane == avs.AVS_PLANAR_V: return self.cdata.offsetV
        return self.cdata.offset
    
    def get_read_ptr(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_read_ptr_p(self.cdata, plane)
    
    def is_writable(self):
        return bool(avs.avs_is_writable(self.cdata))
    
    def get_write_ptr(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_write_ptr_p(self.cdata, plane)


class AVS_Value(object):
    
    def __init__(self, value=None, env=None, release_on_del=True):
        self.cdata = ffi.new('AVS_Value *', avs.avs_void)
        self.env = env # for using with clips, we assume all belong to the same env 
        self._release_on_del = release_on_del
        if value is not None:
            self.set_value(value, env)
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.release()
    
    def __str__(self):
        return str(self.get_value())
    
    def __repr__(self):
        return repr(self.get_value())
    
    # set methods
    
    def set_value(self, value, env=None):
        if   isinstance(value, bool):       self.set_bool(value)
        elif isinstance(value, int):        self.set_int(value)
        elif isinstance(value, float):      self.set_float(value)
        elif isinstance(value, basestring): self.set_string(value, env)
        elif isinstance(value, AVS_Clip):   self.set_clip(value)
        elif isinstance(value, AVS_Value):  self.copy_from(value)
        elif isinstance(value, ffi.CData):  self.set_cdata(value)
        elif isinstance(value, collections.Iterable): self.set_array(value)
        else:
            raise AvisynthError('invalid type: {type}'.format(type=type(value)))
    
    def __call__(self, val, env=None):
        self.set_value(val, env)
    
    def copy_from(self, value):
        avs.avs_copy_value_w(self.cdata, value.cdata)
        self.env = value.env
        self._release_on_del = value._release_on_del
    
    def set_void(self):
        self.copy_from(avs_void)
    
    def set_cdata(self, value):
        if self.is_defined():
            self.release()
        self.cdata = value
    
    def set_bool(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_bool_w(value, self.cdata)
    
    def set_int(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_int_w(value, self.cdata)
    
    def set_float(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_float_w(value, self.cdata)
    
    def set_string(self, value, env=None):
        if self.is_defined():
            self.release()
        if isinstance(value, unicode):
            # mbcs will replace invalid characters anyway
            value = value.encode(encoding, 'backslashreplace')
        chars = ffi.new('char[]', value)
        env = env or self.env
        if isinstance(env, AVS_ScriptEnvironment):
            chars = env.save_string(chars)
        avs.avs_new_value_string_w(chars, self.cdata)
    
    def set_error(self, value, env=None):
        if self.is_defined():
            self.release()
        if isinstance(value, unicode):
            value = value.encode(encoding, 'backslashreplace')
        chars = ffi.new('char[]', value)
        env = env or self.env
        if isinstance(env, AVS_ScriptEnvironment):
            chars = env.save_string(chars)
        avs.avs_new_value_error_w(chars, self.cdata)
    
    def set_clip(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_clip_w(value.cdata, self.cdata)
    
    def set_array(self, values, env=None):
        if self.is_defined():
            self.release()
        env = env or self.env
        length = len(values)
        avs_values = ffi.new('AVS_Value []', length)
        for i, value in enumerate(values):
            if not isinstance(value, AVS_Value):
                value = AVS_Value(value, env)
            avs.avs_copy_value_w(ffi.addressof(avs_values[i]), value.cdata)
        avs.avs_new_value_array_w(avs_values, length, self.cdata)
    
    # check type methods
    
    def is_defined(self):
        return bool(avs.avs_defined_w(self.cdata))
    
    def get_type(self):
        if self.is_bool():
            type = 'bool'
        elif self.is_int():
            type = 'int'
        elif self.is_float():
            type = 'float'
        elif self.is_string():
            type = 'string'
        elif self.is_error():
            type = 'error'
        elif self.is_clip():
            type = 'clip'
        elif self.is_array():
            type = 'array'
        else:
            type = None
        return type
    
    def is_bool(self):
        return bool(avs.avs_is_bool_w(self.cdata))
    
    def is_int(self):
        return bool(avs.avs_is_int_w(self.cdata))
    
    def is_float(self):
        return bool(avs.avs_is_float_w(self.cdata))
    
    def is_string(self):
        return bool(avs.avs_is_string_w(self.cdata))
    
    def is_error(self):
        return bool(avs.avs_is_error_w(self.cdata))
    
    def is_clip(self):
        return bool(avs.avs_is_clip_w(self.cdata))
    
    def is_array(self):
        return bool(avs.avs_is_array_w(self.cdata))
    
    # get methods
    
    def get_value(self, env=None):     
        if   self.is_bool():   return self.as_bool()
        elif self.is_int():    return self.as_int()
        elif self.is_float():  return self.as_float()
        elif self.is_string(): return self.as_string()
        elif self.is_error():  return self.as_error()
        elif self.is_clip():   return self.as_clip(env)
        elif self.is_array():  return self.as_array(env)
    
    def as_bool(self):
        if self.is_bool():
            bool(avs.avs_as_bool_w(self.cdata))
        else:
            raise AvisynthError('Not a bool')
    
    def as_int(self):
        if self.is_int():
            return avs.avs_as_int_w(self.cdata)
        else:
            raise AvisynthError('Not an int')
    
    def as_float(self):
        if self.is_float():
            return avs.avs_as_float_w(self.cdata)
        else:
            raise AvisynthError('Not a float')
    
    def as_string(self):
        if self.is_string():
            chars = avs.avs_as_string_w(self.cdata)
            if chars == ffi.NULL:
                return ''
            return ffi.string(chars)
        else:
            raise AvisynthError('Not a string')
    
    def as_error(self):
        if self.is_error():
            chars = avs.avs_as_error_w(self.cdata)
            if chars == ffi.NULL:
                return ''
            return ffi.string(chars)
        else:
            raise AvisynthError('Not an error')
    
    def as_clip(self, env=None):
        if self.is_clip():
            env = env or self.env
            if not isinstance(env, AVS_ScriptEnvironment):
                raise AvisynthError('AVS_Value.as_clip needs an environment')
            return AVS_Clip(avs.avs_take_clip_w(self.cdata, env.cdata))
        else:
            raise AvisynthError('Not a clip')
    
    def as_array(self, env=None):
        if self.is_array():
            return [self.array_elt(i, env) for i in range(self.array_size())]
        else:
            raise AvisynthError('Not an array')
    
    def array_size(self):
        return self.cdata.array_size if self.is_array() else 1
    
    def array_elt(self, index, env=None):
        if not 0 <= index < self.array_size():
            raise IndexError 
        return AVS_Value(avs.avs_array_elt_w(self.cdata, index), 
                         env=env or self.env, release_on_del=False).get_value()
    
    def __len__(self):
        return self.array_size()
    
    def __getitem__(self, index):
        if isinstance(index, slice):
            pass # TODO
        else:
            return self.array_elt(index)
    
    # free memory
    
    def release(self):
        if self.is_array():
            for index in range(self.array_size()):
                avs.avs_release_value_w(avs.avs_array_elt_w(self.cdata, index))
        avs.avs_release_value_w(self.cdata)
        if self.is_defined():
            self.set_void()
    
    def __del__(self):
        if self._release_on_del:
            self.release()


class AVS_Clip(object):
    
    def __init__(self, clip):
        self.cdata = clip
        self._error = None # additional error info
    
    def __del__(self):
        avs.avs_release_clip(self.cdata)
    
    def copy_clip(self):
        return avs.avs_copy_clip(self.cdata)
    
    def get_error(self):
        err = avs.avs_clip_get_error(self.cdata)
        if err == ffi.NULL:
            err = self._error
        else:
            err = ffi.string(err)
        self._error = None # avs_clip_get_error is used for more than get_frame
        return err
    
    def get_video_info(self):
        return AVS_VideoInfo(avs.avs_get_video_info(self.cdata))
    
    def get_version(self):
        return avs.avs_get_version(self.cdata)
    
    def get_frame(self, n):
        # The returned video frame must be released with avs_release_video_frame
        self._error = None
        try:
            return AVS_VideoFrame(avs.avs_get_frame(self.cdata, n))
        except Exception as err: # crashes
            # Clear the exception traceback in order to avoid keeping an 
            # additional reference to the clip, which would cause its 
            # destruction to be postponed until the process finishes (if 
            # that's the last exception). It would then cause a new exception 
            # as the env doesn't exist anymore at that point (maybe even 
            # avisynth was already unloaded).
            self._error = ''.join(traceback.format_exception_only(type(err), err))
            sys.exc_clear()
    
    def get_parity(self, n):
        """return field parity if field_based, else parity of first field in frame"""
        return avs.avs_get_parity(self.cdata, n)
    
    def get_audio(self, buf, start, count):
        # start and count are in samples
        return avs.avs_get_audio(self.cdata, buf, start, count)
    
    def set_cache_hints(self, cachehints, frame_range):
        return avs.avs_set_cache_hints(self.cdata, cachehints, frame_range)


class AVS_ScriptEnvironment(object):
    
    def __init__(self, version=3):
        self.cdata = avs.avs_create_script_environment(version)
    
    def __del__(self):
        avs.avs_delete_script_environment(self.cdata)
    
    def get_error(self): # XXX: only on interface 5
        err = avs.avs_get_error(self.cdata)
        if err == ffi.NULL:
            return None
        return ffi.string(err)
    
    def get_cpu_flags(self):
        return avs.avs_get_cpu_flags(self.cdata)
    
    def check_version(self, version):
        # 0 -> True, -1 -> False
        return not avs.avs_check_version(self.cdata, version)
    
    def save_string(self, chars):
        return avs.avs_save_string(self.cdata, chars, len(chars))
    
    def sprintf(self, fmt, *args): # every arg must be ffi.CData
        chars = avs.avs_sprintf(self.cdata, fmt, *args)
        if chars == ffi.NULL:
            return ''
        return ffi.string(chars)
    
    def vsprintf(self, fmt, val): # TODO (never)
        # note: val is really a va_list; I hope everyone typedefs va_list to a pointer
        chars = avs.avs_vsprintf(self.cdata, fmt, val)
        if chars == ffi.NULL:
            return ''
        return ffi.string(chars)
    
    def function_exists(self, name):
        return bool(avs.avs_function_exists(self.cdata, name))
    
    def invoke(self, name, args=[], arg_names=None):
        # args needs to be an iterable
        if not isinstance(args, AVS_Value):
            args = AVS_Value(args, env=self)
        if arg_names is None:
            arg_names = ffi.NULL
        else:
            if isinstance(arg_names, basestring):
                arg_names = [arg_names]
            arg_names2 = [ffi.new('char[]', name) for name in arg_names]
            arg_names = ffi.new('char*[]', arg_names2)
        ret = AVS_Value(env=self)
        avs.avs_invoke_w(self.cdata, name, args.cdata, arg_names, ret.cdata)
        if ret.is_error():
            raise AvisynthError(ret.as_error())
        return ret.get_value()
    
    def get_var(self, name, type=False):
        if isinstance(name, unicode):
            name = name.encode(encoding, 'backslashreplace')
        value = AVS_Value(env=self)
        avs.avs_get_var_w(self.cdata, name, value.cdata)
        if value.get_type() is None:
            raise AvisynthError('NotFound')
        if type:
            return value.get_value(), value.get_type()
        return value.get_value()
    
    def set_var(self, name, value):
        if not isinstance(value, AVS_Value):
            value = AVS_Value(value, self)
        return avs.avs_set_var_w(self.cdata, name, value.cdata)
    
    def set_global_var(self, name, value):
        if not isinstance(value, AVS_Value):
            value = AVS_Value(value, self)
        return avs.avs_set_global_var_w(self.cdata, name, value.cdata)
    
    def new_video_frame_a(self, vi, align=avs.AVS_FRAME_ALIGN):
        # align should be at least 16
        return avs.avs_new_video_frame_a(self.cdata, vi, align)
    
    def make_writable(self, video_frame):
        video_frame_p = ffi.new('AVS_VideoFrame * *', video_frame.cdata)
        ret = avs.avs_make_writable(self.cdata, video_frame_p) 
        video_frame.cdata = video_frame_p[0]
        return ret
    
    def bit_blt(self, dstp, dst_pitch, srcp, src_pitch, row_size, height):
        avs.avs_bit_blt(self.cdata, dstp, dst_pitch, srcp, src_pitch, row_size, height)
    
    def subframe(self, video_frame, rel_offset, new_pitch, new_row_size, new_height):
        return avs.avs_subframe(self.cdata, video_frame.cdata, rel_offset, 
                                new_pitch, new_row_size, new_height)
    
    def subframe_planar(self, video_frame, rel_offset, new_pitch, new_row_size, 
                        new_height, rel_offsetU, rel_offsetV, new_pitchUV):
        return avs.avs_subframe_planar(self.cdata, video_frame.cdata, 
                        rel_offset, new_pitch, new_row_size, new_height, 
                        rel_offsetU, rel_offsetV, new_pitchUV)
        
    def set_memory_max(self, memory):
        return avs.avs_set_memory_max(self.cdata, memory)
    
    def set_working_dir(self, new_dir):
        if isinstance(new_dir, unicode):
            new_dir = new_dir.encode(encoding, 'backslashreplace')
        return avs.avs_set_working_dir(self.cdata, new_dir)


class AvisynthError(Exception):
    pass

if not abi:
    # TODO: find out why 'avs' is None for 'avs_void'
    avs_void = AVS_Value(release_on_del=False)


def test():

    env = AVS_ScriptEnvironment(3)
    print('environment created:', env)
    err = env.get_error()
    if err is not None:
        print('error:', err)
        return
    print('checking for interface 3:', env.check_version(3))
    print('checking for interface 33:', env.check_version(33))
    
    if abi:     # libffi doesn't support passing structs or unions
        return  # with bit-fields by value
    
    print('interface:', avs.AVISYNTH_INTERFACE_VERSION)
    print(env.invoke('VersionString'))
    
    print('\nsome internal functions...')
    for function_name in env.get_var('$InternalFunctions$').split()[:10]:
        try:
            params = env.get_var('$Plugin!' + function_name + '!Param$')
        except AvisynthError as err:
            if str(err) != 'NotFound': raise
        else:
            print(' ', function_name, params)
    var_name, value = 'test var', 'some text'
    print('\nsetting a string variable with value {0}'.format(repr(value)))
    env.set_var(var_name, value)
    print('value retrieved:', repr(env.get_var(var_name))) # check save_string
    print('\ninvoking...')
    try:
#        ret = env.invoke('Version')
        ret = env.invoke('BlankClip', [100, 200, 300])
#        ret = env.invoke('Eval', 
#                         ['assert(false, "assert message")', 'script title'])
    except AvisynthError as err:
        print('error:', env.get_error())
    else:
        if isinstance(ret, AVS_Clip):
            clip = ret
            AVS_Value(AVS_Value(clip, env), env).get_value() # test passing clip
            print(clip.get_video_info())
            frame = clip.get_frame(5)
            err = clip.get_error()
            if err:
                print('error:', err)
            else:
                print(frame)
                frame.get_read_ptr()[0:20]
        else:
            print('value:', ret)

if __name__ == '__main__':
    test()
